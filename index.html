<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChatTalk - Professional Chat Room</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #f3f4f6, #e5e7eb);
            min-height: 100vh;
            margin: 0;
        }
        
        #messages {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
            background: white;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 1.5rem;
        }
        
        .message {
            margin-bottom: 1.5rem;
            padding: 1rem;
            border-radius: 0.75rem;
            max-width: 85%;
            position: relative;
        }
        
        .message.sent {
            background: #3b82f6;
            color: white;
            margin-left: auto;
        }
        
        .message.received {
            background: #e5e7eb;
            color: #1f2937;
            margin-right: auto;
        }
        
        .message.system {
            background: #fef3c7;
            color: #b45309;
            text-align: center;
            margin: 0.75rem auto;
        }
        
        .sender {
            font-weight: 600;
            margin-bottom: 0.5rem;
        }
        
        .message-menu {
            cursor: pointer;
            position: absolute;
            right: 0.75rem;
            top: 0.75rem;
        }
        
        .message-menu-content {
            display: none;
            position: absolute;
            right: 0.75rem;
            top: 2rem;
            background: white;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            border-radius: 0.5rem;
            z-index: 10;
        }
        
        .message-menu-content button {
            display: block;
            padding: 0.75rem 1.5rem;
            width: 100%;
            text-align: left;
            background: none;
            border: none;
            cursor: pointer;
        }
        
        .message-menu-content button:hover {
            background: #f3f4f6;
        }
        
        .user-avatar {
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            background: #6b7280;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            margin-right: 0.75rem;
        }
        
        .user-avatar img {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: cover;
        }
        
        .users-more {
            cursor: pointer;
            background: #3b82f6;
            color: white;
            padding: 0 1rem;
            border-radius: 0.5rem;
        }
        
        .users-popup {
            display: none;
            position: absolute;
            top: 3.5rem;
            right: 0;
            background: white;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            border-radius: 0.75rem;
            z-index: 20;
            width: 18rem;
        }
        
        .users-popup.active {
            display: block;
        }
        
        .user-item {
            display: flex;
            align-items: center;
            padding: 0.75rem;
            border-bottom: 1px solid #e5e7eb;
        }
        
        .user-item-avatar {
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            background: #6b7280;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            margin-right: 1rem;
        }
        
        .user-item-avatar img {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: cover;
        }
        
        .call-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .call-container {
            background: white;
            border-radius: 0.75rem;
            width: 90%;
            max-width: 64rem;
            padding: 1.5rem;
            position: relative;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .call-participant {
            position: relative;
            margin: 0.75rem;
        }
        
        .call-participant video {
            width: 100%;
            max-width: 24rem;
            border-radius: 0.75rem;
            background: #1f2937;
        }
        
        .participant-name {
            position: absolute;
            bottom: 0.75rem;
            left: 0.75rem;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            font-size: 1rem;
        }
        
        .call-control-button {
            width: 3.5rem;
            height: 3.5rem;
            border-radius: 50%;
            background: #1f2937;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            margin: 0 0.75rem;
            transition: background 0.3s;
        }
        
        .call-control-button:hover {
            background: #374151;
        }
        
        .call-control-button.end-call {
            background: #dc2626;
        }
        
        .call-control-button.end-call:hover {
            background: #b91c1c;
        }
        
        .incoming-call-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .incoming-call-container {
            background: white;
            border-radius: 0.75rem;
            padding: 2rem;
            width: 90%;
            max-width: 28rem;
            text-align: center;
        }
        
        .incoming-call-user {
            font-size: 1.5rem;
            font-weight: 600;
            color: #1f2937;
        }
        
        .incoming-call-text {
            color: #6b7280;
            margin: 0.75rem 0;
        }
        
        .incoming-call-actions button {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            margin: 0 0.75rem;
            cursor: pointer;
        }
        
        .incoming-call-accept {
            background: #22c55e;
            color: white;
        }
        
        .incoming-call-decline {
            background: #dc2626;
            color: white;
        }
        
        .file-input {
            display: none;
        }
        
        .file-label {
            padding: 0.75rem;
            background: #6b7280;
            color: white;
            border-radius: 0.5rem;
            cursor: pointer;
        }
        
        .status-dot {
            width: 0.75rem;
            height: 0.75rem;
            border-radius: 50%;
            background: #22c55e;
            display: inline-block;
            margin-right: 0.75rem;
        }
        
        .status-dot.offline {
            background: #dc2626;
        }
        
        .spinner {
            display: none;
            border: 4px solid #f3f4f6;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 2rem;
            height: 2rem;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        
        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }
        
        .reaction {
            display: inline-block;
            margin-left: 0.5rem;
            cursor: pointer;
        }
        
        .typing-indicator {
            font-style: italic;
            color: #6b7280;
            margin-bottom: 0.5rem;
        }
        
        .read-receipt {
            font-size: 0.75rem;
            color: #6b7280;
            margin-top: 0.25rem;
        }
        
        .call-status {
            background: #fef3c7;
            color: #b45309;
            padding: 1rem;
            border-radius: 0.75rem;
            margin-bottom: 1rem;
            display: none;
            font-weight: 500;
        }
        
        .call-status.active {
            display: block;
        }
        
        @media (max-width: 640px) {
            .call-participant video {
                max-width: 100%;
            }
            .call-container {
                width: 95%;
            }
        }
    </style>
</head>

<body>
    <div id="loginArea" class="flex items-center justify-center min-h-screen">
        <div class="bg-white p-8 rounded-lg shadow-lg w-full max-w-md">
            <div class="flex items-center justify-center mb-6">
                <h1 class="text-3xl font-bold text-gray-800">ChatTalk</h1>
            </div>
            <h2 class="text-xl font-semibold text-gray-700 mb-6 text-center">Join Chat Room</h2>
            <input type="text" id="username" placeholder="Enter username" required class="w-full p-3 mb-4 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
            <input type="text" id="avatarUrl" placeholder="Avatar URL (optional)" class="w-full p-3 mb-4 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
            <button onclick="connect()" class="w-full bg-blue-500 text-white p-3 rounded-md hover:bg-blue-600 transition">Join Chat</button>
        </div>
    </div>

    <div id="chatArea" style="display: none;" class="container mx-auto p-6 max-w-5xl">
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <div class="call-status" id="callStatus"></div>
            <div class="flex items-center justify-between mb-6">
                <h2 class="text-2xl font-semibold text-gray-800">Chat Room</h2>
                <div class="flex items-center">
                    <div class="status-dot"></div>
                    <span id="status" class="text-gray-600">Connected</span>
                </div>
                <div class="relative">
                    <div class="users-container flex items-center" id="usersContainer"></div>
                    <div class="users-popup" id="usersPopup">
                        <div class="users-popup-header font-semibold p-3 bg-gray-100">Active Users</div>
                        <div class="users-popup-list" id="usersPopupList"></div>
                    </div>
                </div>
                <div class="flex space-x-3">
                    <button id="callButton" class="call-button bg-blue-500 text-white px-5 py-2 rounded-md hover:bg-blue-600" onclick="initiateCall()">📞 Call</button>
                    <button id="leaveCallButton" class="leave-call bg-yellow-500 text-white px-5 py-2 rounded-md hover:bg-yellow-600" style="display: none;" onclick="leaveCall()">Leave Call</button>
                    <button class="end-chat bg-red-500 text-white px-5 py-2 rounded-md hover:bg-red-600" onclick="endChat()">End Chat</button>
                </div>
            </div>
            <div id="typingIndicator" class="typing-indicator" style="display: none;"></div>
            <div id="messages"></div>
            <div class="input-area flex items-center space-x-3">
                <input type="text" id="messageInput" placeholder="Type your message..." required class="flex-1 p-3 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" oninput="handleTyping()">
                <button onclick="sendMessage()" class="bg-blue-500 text-white px-5 py-3 rounded-md hover:bg-blue-600">Send</button>
                <button onclick="shareLocation()" class="bg-gray-500 text-white px-5 py-3 rounded-md hover:bg-gray-600">📍</button>
                <label for="fileInput" class="file-label">📁</label>
                <input type="file" id="fileInput" class="file-input">
            </div>
        </div>
    </div>

    <div class="call-modal" id="callModal">
        <div class="call-container">
            <div class="call-header flex items-center justify-between mb-6">
                <div class="call-title text-xl font-semibold text-gray-800">Group Call</div>
                <div class="flex items-center">
                    <div id="callSpinner" class="spinner"></div>
                    <div class="call-duration text-gray-600 ml-3" id="callDuration">00:00</div>
                </div>
            </div>
            <div class="call-participants grid grid-cols-1 sm:grid-cols-2 gap-6" id="callParticipants"></div>
            <div class="call-controls flex justify-center mt-6">
                <div class="call-control-button mute" onclick="toggleMute()">
                    <span id="muteIcon">🎙️</span>
                </div>
                <div class="call-control-button video" onclick="toggleVideo()">
                    <span id="videoIcon">📹</span>
                </div>
                <div id="endCallButton" class="call-control-button end-call" onclick="endCall()" style="display: none;">
                    <span>📵</span>
                </div>
            </div>
        </div>
    </div>

    <div class="incoming-call-modal" id="incomingCallModal">
        <div class="incoming-call-container">
            <div class="incoming-call-info">
                <div class="incoming-call-user" id="incomingCallUser">User</div>
                <div class="incoming-call-text">is calling you...</div>
            </div>
            <div class="incoming-call-actions flex justify-center mt-6">
                <button class="incoming-call-accept" onclick="acceptCall()">Accept</button>
                <button class="incoming-call-decline" onclick="declineCall()">Decline</button>
            </div>
        </div>
    </div>

    <audio id="ringtone" loop>
        <source src="https://www.soundjay.com/phone/sounds/telephone-ring-01.mp3" type="audio/mpeg">
    </audio>

    <script>
        let ws;
        let username;
        let avatarUrl;
        let userList = [];
        let currentCallId = null;
        let callInitiator = null;
        let callParticipants = [];
        let callDurationInterval;
        let callStartTime;
        let localStream;
        let peerConnections = {};
        let isMuted = false;
        let isVideoOff = false;
        let callParticipantsCount = 0;
        let typingTimeout;
        let isRingtonePlaying = false;
        const ringtone = document.getElementById('ringtone');

        if (Notification.permission !== 'granted') {
            Notification.requestPermission();
        }

        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('messageInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') sendMessage();
            });

            document.getElementById('fileInput').addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file) sendFile(file);
            });

            window.addEventListener('beforeunload', endChat);

            window.addEventListener('click', function(event) {
                if (!event.target.matches('.message-menu, .message-menu *')) {
                    document.querySelectorAll('.message-menu-content').forEach(dropdown => {
                        dropdown.style.display = 'none';
                    });
                }
                if (!event.target.matches('.users-more, .users-popup, .users-popup *')) {
                    document.getElementById('usersPopup').classList.remove('active');
                }
            });
        });

        function showNotification(title, body) {
            if (Notification.permission === 'granted' && document.hidden) {
                new Notification(title, {
                    body
                });
            }
        }

        function updateCallStatus() {
            const callStatus = document.getElementById('callStatus');
            const callButton = document.getElementById('callButton');
            const leaveCallButton = document.getElementById('leaveCallButton');
            const endCallButton = document.getElementById('endCallButton');
            if (currentCallId) {
                callStatus.classList.add('active');
                callStatus.textContent = `Ongoing Call (ID: ${currentCallId}) with ${callParticipants.join(', ')}`;
                callButton.disabled = true;
                callButton.classList.add('opacity-50', 'cursor-not-allowed');
                leaveCallButton.style.display = callParticipants.includes(username) ? 'inline-block' : 'none';
                endCallButton.style.display = username === callInitiator ? 'inline-block' : 'none';
            } else {
                callStatus.classList.remove('active');
                callStatus.textContent = '';
                callButton.disabled = false;
                callButton.classList.remove('opacity-50', 'cursor-not-allowed');
                leaveCallButton.style.display = 'none';
                endCallButton.style.display = 'none';
            }
        }

        function addMessage(text, type = 'received', sender = '', isFile = false, isImage = false, messageId = Date.now(), reactions = [], readBy = []) {
            const messages = document.getElementById('messages');
            const existingMessage = document.querySelector(`[data-timestamp="${messageId}"]`);
            if (existingMessage) return; // Prevent duplicate messages
            const messageElement = document.createElement('div');
            messageElement.className = `message ${type}`;
            messageElement.setAttribute('data-timestamp', messageId);

            if (sender) {
                const senderElement = document.createElement('div');
                senderElement.className = 'sender';
                senderElement.textContent = sender;
                messageElement.appendChild(senderElement);
            }

            const contentElement = document.createElement('div');
            if (isFile) {
                if (isImage) {
                    const image = document.createElement('img');
                    image.src = text;
                    image.className = 'max-w-full rounded-md';
                    contentElement.appendChild(image);
                } else {
                    const fileLink = document.createElement('a');
                    fileLink.href = text;
                    fileLink.textContent = 'Download File';
                    fileLink.download = text.split('/').pop();
                    fileLink.className = 'text-blue-500 underline';
                    contentElement.appendChild(fileLink);
                }
            } else {
                contentElement.textContent = text;
            }
            messageElement.appendChild(contentElement);

            const reactionsElement = document.createElement('div');
            reactionsElement.className = 'reactions';
            reactions.forEach(r => {
                const reactionSpan = document.createElement('span');
                reactionSpan.className = 'reaction';
                reactionSpan.textContent = r.emoji;
                reactionSpan.title = r.username;
                reactionsElement.appendChild(reactionSpan);
            });
            const reactionButton = document.createElement('span');
            reactionButton.className = 'reaction';
            reactionButton.textContent = '😊';
            reactionButton.onclick = () => addReaction(messageId);
            reactionsElement.appendChild(reactionButton);
            messageElement.appendChild(reactionsElement);

            const readReceiptElement = document.createElement('div');
            readReceiptElement.className = 'read-receipt';
            readReceiptElement.textContent = readBy.length ? `Read by: ${readBy.join(', ')}` : '';
            messageElement.appendChild(readReceiptElement);

            if (type === 'sent') {
                const messageMenu = document.createElement('div');
                messageMenu.className = 'message-menu';
                messageMenu.textContent = '⋮';
                messageMenu.onclick = function() {
                    const menuContent = messageElement.querySelector('.message-menu-content');
                    menuContent.style.display = menuContent.style.display === 'block' ? 'none' : 'block';
                };
                const messageMenuContent = document.createElement('div');
                messageMenuContent.className = 'message-menu-content';
                const editButton = document.createElement('button');
                editButton.textContent = 'Edit';
                editButton.onclick = function() {
                    const originalText = contentElement.textContent;
                    const messageInput = document.getElementById('messageInput');
                    messageInput.value = originalText;
                    ws.send(JSON.stringify({
                        type: 'edit',
                        username: username,
                        messageId: messageId,
                        newMessage: originalText
                    }));
                    messageElement.style.display = 'none';
                };
                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Delete';
                deleteButton.onclick = function() {
                    ws.send(JSON.stringify({
                        type: 'delete',
                        username: username,
                        messageId: messageId
                    }));
                    messageElement.remove();
                };
                messageMenuContent.appendChild(editButton);
                messageMenuContent.appendChild(deleteButton);
                messageElement.appendChild(messageMenu);
                messageElement.appendChild(messageMenuContent);
            }

            messages.appendChild(messageElement);
            messages.scrollTop = messages.scrollHeight;

            if (type === 'received' && sender !== username) {
                showNotification(`${sender} sent a message`, text);
                ws.send(JSON.stringify({
                    type: 'read',
                    username: username,
                    messageId: messageId
                }));
            }
        }

        function addReaction(messageId) {
            const emoji = prompt('Enter an emoji to react with:');
            if (emoji) {
                ws.send(JSON.stringify({
                    type: 'reaction',
                    username: username,
                    messageId: messageId,
                    emoji: emoji
                }));
            }
        }

        function handleTyping() {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;
            ws.send(JSON.stringify({
                type: 'typing',
                username: username,
                isTyping: true
            }));
            clearTimeout(typingTimeout);
            typingTimeout = setTimeout(() => {
                ws.send(JSON.stringify({
                    type: 'typing',
                    username: username,
                    isTyping: false
                }));
            }, 3000);
        }

        function updateTypingIndicator(typingUsers) {
            const typingIndicator = document.getElementById('typingIndicator');
            if (typingUsers.length > 0) {
                typingIndicator.textContent = `${typingUsers.join(', ')} ${typingUsers.length > 1 ? 'are' : 'is'} typing...`;
                typingIndicator.style.display = 'block';
            } else {
                typingIndicator.style.display = 'none';
            }
        }

        function connect() {
            username = document.getElementById('username').value.trim();
            avatarUrl = document.getElementById('avatarUrl').value.trim();

            if (!username) {
                alert('Please enter a username');
                return;
            }

            if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
                alert('This application requires a secure context (HTTPS or localhost). Please access via http://localhost:5001.');
                return;
            }

            updateStatus('Connecting...', false);
            ws = new WebSocket('ws://localhost:8887');

            ws.onopen = function() {
                updateStatus('Connected', true);
                document.getElementById('loginArea').style.display = 'none';
                document.getElementById('chatArea').style.display = 'block';
                ws.send(JSON.stringify({
                    type: 'join',
                    username: username,
                    avatar: avatarUrl
                }));
                addMessage(`Welcome to the chat room, ${username}!`, 'system');
            };

            ws.onclose = function() {
                updateStatus('Disconnected', false);
                document.getElementById('loginArea').style.display = 'block';
                document.getElementById('chatArea').style.display = 'none';
                addMessage('Disconnected from chat server', 'system');
                if (currentCallId) cleanupCall();
            };

            ws.onerror = function(error) {
                updateStatus('Error connecting', false);
                console.error('WebSocket error:', error);
                addMessage('Error connecting to server', 'system');
            };

            ws.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    console.log('Received message:', data);
                    switch (data.type) {
                        case 'join':
                            addMessage(`${data.username} joined the chat`, 'system');
                            updateUserList(data.userList);
                            break;
                        case 'leave':
                            addMessage(`${data.username} left the chat`, 'system');
                            updateUserList(data.userList);
                            break;
                        case 'message':
                            addMessage(data.message, data.username === username ? 'sent' : 'received', data.username, false, false, data.messageId);
                            break;
                        case 'file':
                            if (data.username !== username) {
                                addMessage(data.fileUrl, 'received', data.username, true, data.isImage, data.messageId);
                            }
                            break;
                        case 'location':
                            addLocation(data.username, data.latitude, data.longitude);
                            break;
                        case 'delete':
                            const messageToDelete = document.querySelector(`[data-timestamp="${data.messageId}"]`);
                            if (messageToDelete) messageToDelete.remove();
                            break;
                        case 'edit':
                            const messageToEdit = document.querySelector(`[data-timestamp="${data.messageId}"]`);
                            if (messageToEdit) {
                                const contentDiv = messageToEdit.querySelector('div:not(.sender):not(.reactions):not(.read-receipt)');
                                if (contentDiv) contentDiv.textContent = data.newMessage;
                            }
                            break;
                        case 'user-list-update':
                            updateUserList(data.userList);
                            break;
                        case 'call-initiate':
                            handleIncomingCall(data.callId, data.username);
                            break;
                        case 'call-accept':
                            handleUserJoinedCall(data.callId, data.username, data.participants);
                            break;
                        case 'call-reject':
                            handleCallRejected(data.callId, data.username);
                            break;
                        case 'call-end':
                            handleCallEnded(data.callId, data.username);
                            break;
                        case 'call-user-left':
                            handleUserLeftCall(data.callId, data.username, data.participants);
                            break;
                        case 'call-signal':
                            handleCallSignal(data.callId, data.username, data.signal);
                            break;
                        case 'call-info':
                            handleCallInfo(data.callId, data.initiator, data.participants);
                            break;
                        case 'typing':
                            updateTypingIndicator(data.typingUsers);
                            break;
                        case 'reaction':
                            const messageWithReaction = document.querySelector(`[data-timestamp="${data.messageId}"]`);
                            if (messageWithReaction) {
                                const reactionsDiv = messageWithReaction.querySelector('.reactions');
                                const reactionSpan = document.createElement('span');
                                reactionSpan.className = 'reaction';
                                reactionSpan.textContent = data.emoji;
                                reactionSpan.title = data.username;
                                reactionsDiv.insertBefore(reactionSpan, reactionsDiv.lastChild);
                            }
                            break;
                        case 'read':
                            const messageWithRead = document.querySelector(`[data-timestamp="${data.messageId}"]`);
                            if (messageWithRead) {
                                const readReceiptDiv = messageWithRead.querySelector('.read-receipt');
                                readReceiptDiv.textContent = `Read by: ${data.readBy.join(', ')}`;
                            }
                            break;
                        case 'error':
                            addMessage(`Error: ${data.message}`, 'system');
                            break;
                    }
                } catch (e) {
                    console.error('Error parsing message:', e);
                }
            };
        }

        function updateStatus(text, connected) {
            const status = document.getElementById('status');
            const dot = document.querySelector('.status-dot');
            status.textContent = text;
            dot.classList.toggle('offline', !connected);
        }

        function updateUserList(users) {
            userList = users;
            const usersContainer = document.getElementById('usersContainer');
            usersContainer.innerHTML = '';

            const visibleUsers = users.slice(0, 3);
            visibleUsers.forEach(user => {
                const userAvatar = document.createElement('div');
                userAvatar.className = 'user-avatar';
                if (user.avatar) {
                    const img = document.createElement('img');
                    img.src = user.avatar;
                    img.alt = user.username;
                    img.onerror = function() {
                        this.onerror = null;
                        this.parentNode.textContent = user.username.charAt(0).toUpperCase();
                    };
                    userAvatar.appendChild(img);
                } else {
                    userAvatar.textContent = user.username.charAt(0).toUpperCase();
                }
                usersContainer.appendChild(userAvatar);
            });

            if (users.length > 3) {
                const moreButton = document.createElement('div');
                moreButton.className = 'users-more';
                moreButton.textContent = '+' + (users.length - 3);
                moreButton.onclick = toggleUsersPopup;
                usersContainer.appendChild(moreButton);
            }

            const usersPopupList = document.getElementById('usersPopupList');
            usersPopupList.innerHTML = '';
            users.forEach(user => {
                const userItem = document.createElement('div');
                userItem.className = 'user-item';
                const userItemAvatar = document.createElement('div');
                userItemAvatar.className = 'user-item-avatar';
                if (user.avatar) {
                    const img = document.createElement('img');
                    img.src = user.avatar;
                    img.alt = user.username;
                    img.onerror = function() {
                        this.onerror = null;
                        this.parentNode.textContent = user.username.charAt(0).toUpperCase();
                    };
                    userItemAvatar.appendChild(img);
                } else {
                    userItemAvatar.textContent = user.username.charAt(0).toUpperCase();
                }
                const userItemInfo = document.createElement('div');
                userItemInfo.className = 'user-item-info';
                const userItemUsername = document.createElement('div');
                userItemUsername.className = 'user-item-username';
                userItemUsername.textContent = user.username;
                userItemInfo.appendChild(userItemUsername);
                userItem.appendChild(userItemAvatar);
                userItem.appendChild(userItemInfo);
                usersPopupList.appendChild(userItem);
            });
        }

        function toggleUsersPopup() {
            document.getElementById('usersPopup').classList.toggle('active');
        }

        function sendMessage() {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                addMessage('You are not connected to the chat server', 'system');
                return;
            }
            const messageInput = document.getElementById('messageInput');
            const message = messageInput.value.trim();
            if (!message) return;
            const messageId = Date.now();
            ws.send(JSON.stringify({
                type: 'message',
                username: username,
                message: message,
                messageId: messageId
            }));
            addMessage(message, 'sent', username, false, false, messageId);
            messageInput.value = '';
        }

        function sendFile(file) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                addMessage('You are not connected to the chat server', 'system');
                return;
            }
            const formData = new FormData();
            formData.append('file', file);
            fetch('/upload', {
                    method: 'POST',
                    body: formData
                })
                .then(response => response.json())
                .then(data => {
                    if (data.fileUrl) {
                        const isImage = file.type.startsWith('image/');
                        const messageId = Date.now();
                        ws.send(JSON.stringify({
                            type: 'file',
                            username: username,
                            fileUrl: data.fileUrl,
                            isImage: isImage,
                            messageId: messageId
                        }));
                        addMessage(data.fileUrl, 'sent', username, true, isImage, messageId);
                    } else {
                        addMessage('Failed to upload file', 'system');
                    }
                })
                .catch(error => {
                    console.error('Error uploading file:', error);
                    addMessage('Error uploading file', 'system');
                });
        }

        function shareLocation() {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                addMessage('You are not connected to the chat server', 'system');
                return;
            }
            if (!navigator.geolocation) {
                addMessage('Geolocation is not supported by your browser', 'system');
                return;
            }
            navigator.geolocation.getCurrentPosition(
                function(position) {
                    const latitude = position.coords.latitude;
                    const longitude = position.coords.longitude;
                    ws.send(JSON.stringify({
                        type: 'location',
                        username: username,
                        latitude: latitude,
                        longitude: longitude
                    }));
                    addLocation(username, latitude, longitude, true);
                },
                function(error) {
                    addMessage(`Error getting location: ${error.message}`, 'system');
                }
            );
        }

        function addLocation(sender, latitude, longitude, isSender = false) {
            const messages = document.getElementById('messages');
            const messageElement = document.createElement('div');
            messageElement.className = `message ${isSender ? 'sent' : 'received'}`;
            if (sender) {
                const senderElement = document.createElement('div');
                senderElement.className = 'sender';
                senderElement.textContent = sender;
                messageElement.appendChild(senderElement);
            }
            const locationLink = document.createElement('a');
            locationLink.href = `https://www.google.com/maps?q=${latitude},${longitude}`;
            locationLink.textContent = 'View Location on Map';
            locationLink.target = '_blank';
            locationLink.className = 'text-blue-500 underline';
            const locationElement = document.createElement('div');
            locationElement.appendChild(locationLink);
            messageElement.appendChild(locationElement);
            messages.appendChild(messageElement);
            messages.scrollTop = messages.scrollHeight;
        }

        function endChat() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'leave',
                    username: username
                }));
                ws.close();
            }
        }

        function initiateCall() {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                addMessage('You are not connected to the chat server', 'system');
                return;
            }
            if (userList.length < 2) {
                addMessage('No other users are available to call', 'system');
                return;
            }
            if (currentCallId) {
                addMessage('A call is already in progress', 'system');
                return;
            }
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                addMessage('Your browser does not support video/audio calls', 'system');
                return;
            }
            currentCallId = Date.now().toString();
            callInitiator = username;
            callParticipants = [username];
            callParticipantsCount = 1;
            ws.send(JSON.stringify({
                type: 'call-initiate',
                username: username,
                callId: currentCallId
            }));
            document.getElementById('callSpinner').style.display = 'block';
            setupLocalMedia()
                .then(() => {
                    showCallUI();
                    startCallTimer();
                    addMessage('You started a group call. Waiting for participants...', 'system');
                    updateCallStatus();
                })
                .catch(error => {
                    console.error('Error setting up media:', error);
                    addMessage('Failed to access camera/microphone. Please check permissions.', 'system');
                    document.getElementById('callSpinner').style.display = 'none';
                    currentCallId = null;
                    callInitiator = null;
                    updateCallStatus();
                });
        }

        function setupLocalMedia() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                return Promise.reject(new Error('Media devices not supported in this browser'));
            }
            return navigator.mediaDevices.getUserMedia({
                    audio: true,
                    video: true
                })
                .then(stream => {
                    localStream = stream;
                    console.log('Local stream tracks:', stream.getTracks());
                    stream.getAudioTracks().forEach(track => {
                        track.enabled = true;
                        console.log('Audio track:', track);
                    });
                    stream.getVideoTracks().forEach(track => {
                        track.enabled = true;
                        console.log('Video track:', track);
                    });
                    addVideoToCall('local', stream, username);
                    return stream;
                })
                .catch(error => {
                    console.warn('Video failed, trying audio only:', error);
                    return navigator.mediaDevices.getUserMedia({
                            audio: true
                        })
                        .then(stream => {
                            localStream = stream;
                            console.log('Local stream tracks (audio only):', stream.getTracks());
                            stream.getAudioTracks().forEach(track => {
                                track.enabled = true;
                                console.log('Audio track:', track);
                            });
                            addVideoToCall('local', stream, username);
                            return stream;
                        })
                        .catch(err => {
                            console.error('Media setup error:', err);
                            throw err;
                        });
                });
        }

        function addVideoToCall(id, stream, participant) {
            const callParticipants = document.getElementById('callParticipants');
            if (document.getElementById(`participant-${id}`)) return;
            const participantElement = document.createElement('div');
            participantElement.className = 'call-participant';
            participantElement.id = `participant-${id}`;
            const videoElement = document.createElement('video');
            videoElement.autoplay = true;
            videoElement.playsInline = true;
            videoElement.srcObject = stream;
            if (id === 'local') videoElement.muted = true;
            const nameElement = document.createElement('div');
            nameElement.className = 'participant-name';
            nameElement.textContent = participant + (id === 'local' ? ' (You)' : '');
            participantElement.appendChild(videoElement);
            participantElement.appendChild(nameElement);
            callParticipants.appendChild(participantElement);
            console.log('Added video for', participant, 'with stream tracks:', stream.getTracks());
        }

        function showCallUI() {
            document.getElementById('callModal').style.display = 'flex';
            stopRingtone();
        }

        function hideCallUI() {
            document.getElementById('callModal').style.display = 'none';
            stopRingtone();
        }

        function startCallTimer() {
            callStartTime = Date.now();
            const durationElement = document.getElementById('callDuration');
            callDurationInterval = setInterval(() => {
                const duration = Math.floor((Date.now() - callStartTime) / 1000);
                const minutes = Math.floor(duration / 60).toString().padStart(2, '0');
                const seconds = (duration % 60).toString().padStart(2, '0');
                durationElement.textContent = `${minutes}:${seconds}`;
            }, 1000);
        }

        function playRingtone() {
            if (!isRingtonePlaying) {
                isRingtonePlaying = true;
                ringtone.play()
                    .then(() => console.log('Ringtone playing'))
                    .catch(e => {
                        console.error('Ringtone play error:', e);
                        isRingtonePlaying = false;
                    });
            }
        }

        function stopRingtone() {
            if (isRingtonePlaying) {
                ringtone.pause();
                ringtone.currentTime = 0;
                isRingtonePlaying = false;
                console.log('Ringtone stopped');
            }
        }

        function handleCallInfo(callId, initiator, participants) {
            if (currentCallId) return;
            currentCallId = callId;
            callInitiator = initiator;
            callParticipants = participants;
            callParticipantsCount = participants.length;
            document.getElementById('incomingCallUser').textContent = initiator;
            document.getElementById('incomingCallModal').style.display = 'flex';
            playRingtone();
            showNotification('Ongoing Call', `${initiator}'s group call is active with ${participants.join(', ')}`);
            updateCallStatus();
        }

        function handleIncomingCall(callId, initiator) {
            if (currentCallId) {
                ws.send(JSON.stringify({
                    type: 'call-reject',
                    username: username,
                    callId: callId
                }));
                return;
            }
            currentCallId = callId;
            callInitiator = initiator;
            callParticipants = [initiator];
            callParticipantsCount = 1;
            document.getElementById('incomingCallUser').textContent = initiator;
            document.getElementById('incomingCallModal').style.display = 'flex';
            playRingtone();
            showNotification('Incoming Call', `${initiator} is calling you...`);
            updateCallStatus();
        }

        function acceptCall() {
            document.getElementById('incomingCallModal').style.display = 'none';
            stopRingtone();
            document.getElementById('callSpinner').style.display = 'block';
            setupLocalMedia()
                .then(() => {
                    showCallUI();
                    startCallTimer();
                    ws.send(JSON.stringify({
                        type: 'call-accept',
                        username: username,
                        callId: currentCallId
                    }));
                    callParticipants.push(username);
                    callParticipantsCount++;
                    addMessage(`You joined ${callInitiator}'s call`, 'system');
                    document.getElementById('callSpinner').style.display = 'none';
                    updateCallStatus();
                    createPeerConnectionsForParticipants();
                })
                .catch(error => {
                    console.error('Error setting up media:', error);
                    addMessage('Failed to access camera/microphone. Please check permissions and ensure you are using a secure context (http://localhost:5001).', 'system');
                    document.getElementById('callSpinner').style.display = 'none';
                    cleanupCall();
                });
        }

        function declineCall() {
            document.getElementById('incomingCallModal').style.display = 'none';
            stopRingtone();
            ws.send(JSON.stringify({
                type: 'call-reject',
                username: username,
                callId: currentCallId
            }));
            cleanupCall();
        }

        function createPeerConnectionsForParticipants() {
            callParticipants.forEach(user => {
                if (user !== username && !peerConnections[user]) {
                    createPeerConnection(user);
                }
            });
        }

        function handleUserJoinedCall(callId, user, participants) {
            if (callId !== currentCallId) return;
            callParticipants = participants;
            callParticipantsCount = participants.length;
            addMessage(`${user} joined the call`, 'system');
            document.getElementById('callSpinner').style.display = 'none';
            updateCallStatus();
            if (!peerConnections[user]) {
                createPeerConnection(user);
                if (callParticipants.indexOf(username) < callParticipants.indexOf(user)) {
                    const peerConnection = peerConnections[user];
                    peerConnection.createOffer()
                        .then(offer => {
                            console.log('Created offer for', user, offer);
                            return peerConnection.setLocalDescription(offer);
                        })
                        .then(() => {
                            ws.send(JSON.stringify({
                                type: 'call-signal',
                                username: username,
                                target: user,
                                callId: currentCallId,
                                signal: {
                                    type: 'offer',
                                    sdp: peerConnection.localDescription
                                }
                            }));
                            console.log('Sent offer to', user);
                        })
                        .catch(error => {
                            console.error('Error creating offer:', error);
                            addMessage('Failed to establish call connection', 'system');
                        });
                }
            }
        }

        function handleCallRejected(callId, user) {
            if (callId !== currentCallId) return;
            addMessage(`${user} declined the call`, 'system');
            callParticipantsCount--;
            callParticipants = callParticipants.filter(p => p !== user);
            updateCallStatus();
            if (callParticipantsCount <= 1 && username === callInitiator) {
                addMessage('No participants accepted the call. Ending call...', 'system');
                endCall();
            }
        }

        function handleCallEnded(callId, initiator) {
            if (callId !== currentCallId) return;
            addMessage(`${initiator} ended the call`, 'system');
            cleanupCall();
        }

        function handleUserLeftCall(callId, user, participants) {
            if (callId !== currentCallId) return;
            addMessage(`${user} left the call`, 'system');
            callParticipants = participants;
            callParticipantsCount = participants.length;
            updateCallStatus();
            const participantElement = document.getElementById(`participant-${user}`);
            if (participantElement) participantElement.remove();
            if (peerConnections[user]) {
                peerConnections[user].close();
                delete peerConnections[user];
            }
            if (callParticipantsCount <= 1 && username === callInitiator) {
                addMessage('No other participants in the call. Ending call...', 'system');
                endCall();
            }
        }

        function handleCallSignal(callId, user, signal) {
            if (callId !== currentCallId) return;
            if (!peerConnections[user]) createPeerConnection(user);
            const peerConnection = peerConnections[user];
            console.log('Received signal from', user, signal);
            if (signal.type === 'offer') {
                peerConnection.setRemoteDescription(new RTCSessionDescription(signal.sdp))
                    .then(() => peerConnection.createAnswer())
                    .then(answer => {
                        console.log('Created answer for', user, answer);
                        return peerConnection.setLocalDescription(answer);
                    })
                    .then(() => {
                        ws.send(JSON.stringify({
                            type: 'call-signal',
                            username: username,
                            target: user,
                            callId: currentCallId,
                            signal: {
                                type: 'answer',
                                sdp: peerConnection.localDescription
                            }
                        }));
                        console.log('Sent answer to', user);
                    })
                    .catch(error => {
                        console.error('Error handling offer:', error);
                        addMessage('Failed to establish call connection', 'system');
                    });
            } else if (signal.type === 'answer') {
                peerConnection.setRemoteDescription(new RTCSessionDescription(signal.sdp))
                    .catch(error => {
                        console.error('Error handling answer:', error);
                        addMessage('Failed to establish call connection', 'system');
                    });
            } else if (signal.type === 'candidate') {
                peerConnection.addIceCandidate(new RTCIceCandidate(signal.candidate))
                    .catch(error => {
                        console.error('Error adding ICE candidate:', error);
                        addMessage('Failed to establish call connection', 'system');
                    });
            }
        }

        function createPeerConnection(user) {
            const peerConnection = new RTCPeerConnection({
                iceServers: [{
                        urls: 'stun:stun.l.google.com:19302'
                    }, {
                        urls: 'stun:stun1.l.google.com:19302'
                    }
                    // Add TURN server if needed:
                    // { urls: 'turn:your-turn-server', username: 'user', credential: 'pass' }
                ]
            });
            peerConnections[user] = peerConnection;
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                    console.log('Added track for', user, ':', track);
                });
            }
            peerConnection.onicecandidate = event => {
                if (event.candidate) {
                    ws.send(JSON.stringify({
                        type: 'call-signal',
                        username: username,
                        target: user,
                        callId: currentCallId,
                        signal: {
                            type: 'candidate',
                            candidate: event.candidate
                        }
                    }));
                    console.log('Sent ICE candidate to', user, event.candidate);
                }
            };
            peerConnection.ontrack = event => {
                console.log('Received remote stream from', user, event.streams);
                event.streams.forEach(stream => {
                    console.log('Remote stream tracks:', stream.getTracks());
                });
                addVideoToCall(user, event.streams[0], user);
            };
            peerConnection.oniceconnectionstatechange = () => {
                console.log('ICE connection state for', user, ':', peerConnection.iceConnectionState);
                if (peerConnection.iceConnectionState === 'disconnected' || peerConnection.iceConnectionstate === 'failed') {
                    addMessage(`${user} disconnected from the call`, 'system');
                    const participantElement = document.getElementById(`participant-${user}`);
                    if (participantElement) participantElement.remove();
                    peerConnection.close();
                    delete peerConnections[user];
                    callParticipantsCount--;
                    callParticipants = callParticipants.filter(p => p !== user);
                    updateCallStatus();
                    if (callParticipantsCount <= 1 && username === callInitiator) {
                        addMessage('No other participants in the call. Ending call...', 'system');
                        endCall();
                    }
                }
            };
            peerConnection.onnegotiationneeded = () => {
                console.log('Negotiation needed for', user);
                if (callParticipants.indexOf(username) < callParticipants.indexOf(user)) {
                    peerConnection.createOffer()
                        .then(offer => peerConnection.setLocalDescription(offer))
                        .then(() => {
                            ws.send(JSON.stringify({
                                type: 'call-signal',
                                username: username,
                                target: user,
                                callId: currentCallId,
                                signal: {
                                    type: 'offer',
                                    sdp: peerConnection.localDescription
                                }
                            }));
                            console.log('Sent renegotiation offer to', user);
                        })
                        .catch(error => console.error('Renegotiation error:', error));
                }
            };
            return peerConnection;
        }

        function endCall() {
            if (!currentCallId) return;
            if (username !== callInitiator) {
                leaveCall();
                return;
            }
            ws.send(JSON.stringify({
                type: 'call-end',
                username: username,
                callId: currentCallId
            }));
            cleanupCall();
            addMessage('You ended the call', 'system');
        }

        function leaveCall() {
            if (!currentCallId) return;
            ws.send(JSON.stringify({
                type: 'call-end',
                username: username,
                callId: currentCallId
            }));
            cleanupCall();
            addMessage('You left the call', 'system');
        }

        function cleanupCall() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            Object.values(peerConnections).forEach(pc => pc.close());
            peerConnections = {};
            hideCallUI();
            clearInterval(callDurationInterval);
            document.getElementById('callDuration').textContent = '00:00';
            document.getElementById('callParticipants').innerHTML = '';
            document.getElementById('callSpinner').style.display = 'none';
            currentCallId = null;
            callInitiator = null;
            callParticipants = [];
            callParticipantsCount = 0;
            document.getElementById('muteIcon').textContent = '🎙️';
            document.getElementById('videoIcon').textContent = '📹';
            isMuted = false;
            isVideoOff = false;
            stopRingtone();
            updateCallStatus();
        }

        function toggleMute() {
            if (!localStream) return;
            const audioTracks = localStream.getAudioTracks();
            isMuted = !isMuted;
            audioTracks.forEach(track => {
                track.enabled = !isMuted;
                console.log('Audio track enabled:', track.enabled);
            });
            document.getElementById('muteIcon').textContent = isMuted ? '🔇' : '🎙️';
        }

        function toggleVideo() {
            if (!localStream) return;
            const videoTracks = localStream.getVideoTracks();
            isVideoOff = !isVideoOff;
            videoTracks.forEach(track => {
                track.enabled = !isVideoOff;
                console.log('Video track enabled:', track.enabled);
            });
            document.getElementById('videoIcon').textContent = isVideoOff ? '📵' : '📹';
        }
    </script>
</body>

</html>